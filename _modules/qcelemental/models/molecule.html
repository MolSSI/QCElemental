<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qcelemental.models.molecule &mdash; QCElemental 0+untagged.1.g2956421 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/autodoc_pydantic.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MZ67SSL');</script>
<!-- End Google Tag Manager -->
 

</head>

<body class="wy-body-for-nav">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MZ67SSL"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
 

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> QCElemental
          </a>
              <div class="version">
                0+untagged.1.g2956421
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Install QCElemental</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quantities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../physconst.html">Physical Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../periodic_table.html">Periodic Table</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../covalent_radii.html">Covalent Radii</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vanderwaals_radii.html">van der Waals Radii</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">QCSchema Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model_molecule.html">Molecule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model_result.html">AtomicResult</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model_common.html">Common</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">QCElemental API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">QCElemental</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>qcelemental.models.molecule</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qcelemental.models.molecule</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Molecule Object Model</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">ConstrainedFloat</span><span class="p">,</span> <span class="n">ConstrainedInt</span><span class="p">,</span> <span class="n">Field</span><span class="p">,</span> <span class="n">constr</span><span class="p">,</span> <span class="n">validator</span>

<span class="c1"># molparse imports separated b/c https://github.com/python/mypy/issues/7203</span>
<span class="kn">from</span> <span class="nn">..molparse.from_arrays</span> <span class="kn">import</span> <span class="n">from_arrays</span>
<span class="kn">from</span> <span class="nn">..molparse.from_schema</span> <span class="kn">import</span> <span class="n">from_schema</span>
<span class="kn">from</span> <span class="nn">..molparse.from_string</span> <span class="kn">import</span> <span class="n">from_string</span>
<span class="kn">from</span> <span class="nn">..molparse.to_schema</span> <span class="kn">import</span> <span class="n">to_schema</span>
<span class="kn">from</span> <span class="nn">..molparse.to_string</span> <span class="kn">import</span> <span class="n">to_string</span>
<span class="kn">from</span> <span class="nn">..periodic_table</span> <span class="kn">import</span> <span class="n">periodictable</span>
<span class="kn">from</span> <span class="nn">..physical_constants</span> <span class="kn">import</span> <span class="n">constants</span>
<span class="kn">from</span> <span class="nn">..testing</span> <span class="kn">import</span> <span class="n">compare</span><span class="p">,</span> <span class="n">compare_values</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="kn">import</span> <span class="n">deserialize</span><span class="p">,</span> <span class="n">measure_coordinates</span><span class="p">,</span> <span class="n">msgpackext_loads</span><span class="p">,</span> <span class="n">provenance_stamp</span><span class="p">,</span> <span class="n">which_import</span>
<span class="kn">from</span> <span class="nn">.basemodels</span> <span class="kn">import</span> <span class="n">ProtoModel</span><span class="p">,</span> <span class="n">qcschema_draft</span>
<span class="kn">from</span> <span class="nn">.common_models</span> <span class="kn">import</span> <span class="n">Provenance</span><span class="p">,</span> <span class="n">qcschema_molecule_default</span>
<span class="kn">from</span> <span class="nn">.types</span> <span class="kn">import</span> <span class="n">Array</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pydantic.typing</span> <span class="kn">import</span> <span class="n">ReprArgs</span>

<span class="c1"># Rounding quantities for hashing</span>
<span class="n">GEOMETRY_NOISE</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">MASS_NOISE</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">CHARGE_NOISE</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">_extension_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;.npy&quot;</span><span class="p">:</span> <span class="s2">&quot;numpy&quot;</span><span class="p">,</span>
    <span class="s2">&quot;.json&quot;</span><span class="p">:</span> <span class="s2">&quot;json&quot;</span><span class="p">,</span>
    <span class="s2">&quot;.xyz&quot;</span><span class="p">:</span> <span class="s2">&quot;xyz&quot;</span><span class="p">,</span>
    <span class="s2">&quot;.psimol&quot;</span><span class="p">:</span> <span class="s2">&quot;psi4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;.psi4&quot;</span><span class="p">:</span> <span class="s2">&quot;psi4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;.msgpack&quot;</span><span class="p">:</span> <span class="s2">&quot;msgpack-ext&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">float_prep</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">around</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rounds floats to a common value and build positive zeros to prevent hash conflicts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="c1"># Round array</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">around</span><span class="p">)</span>
        <span class="c1"># Flip zeros</span>
        <span class="n">array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">around</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">array</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">around</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">array</span> <span class="o">==</span> <span class="o">-</span><span class="mf">0.0</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Type &#39;</span><span class="si">{}</span><span class="s2">&#39; not recognized&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">array</span>


<span class="k">class</span> <span class="nc">NonnegativeInt</span><span class="p">(</span><span class="n">ConstrainedInt</span><span class="p">):</span>
    <span class="n">ge</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">BondOrderFloat</span><span class="p">(</span><span class="n">ConstrainedFloat</span><span class="p">):</span>
    <span class="n">ge</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">le</span> <span class="o">=</span> <span class="mi">5</span>


<span class="k">class</span> <span class="nc">Identifiers</span><span class="p">(</span><span class="n">ProtoModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Canonical chemical identifiers&quot;&quot;&quot;</span>

    <span class="n">molecule_hash</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">molecular_formula</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">inchi</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">inchikey</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">canonical_explicit_hydrogen_smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">canonical_isomeric_explicit_hydrogen_mapped_smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">canonical_isomeric_explicit_hydrogen_smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">canonical_isomeric_smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">canonical_smiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pubchem_cid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;PubChem Compound ID&quot;</span><span class="p">)</span>
    <span class="n">pubchem_sid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;PubChem Substance ID&quot;</span><span class="p">)</span>
    <span class="n">pubchem_conformerid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;PubChem Conformer ID&quot;</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Config</span><span class="p">(</span><span class="n">ProtoModel</span><span class="o">.</span><span class="n">Config</span><span class="p">):</span>
        <span class="n">serialize_skip_defaults</span> <span class="o">=</span> <span class="kc">True</span>


<div class="viewcode-block" id="Molecule"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule">[docs]</a><span class="k">class</span> <span class="nc">Molecule</span><span class="p">(</span><span class="n">ProtoModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The physical Cartesian representation of the molecular system.</span>

<span class="sd">    A QCSchema representation of a Molecule. This model contains</span>
<span class="sd">    data for symbols, geometry, connectivity, charges, fragmentation, etc while also supporting a wide array of I/O and manipulation capabilities.</span>

<span class="sd">    Molecule objects geometry, masses, and charges are truncated to 8, 6, and 4 decimal places respectively to assist with duplicate detection.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows:</span>

<span class="sd">      * nat: number of atomic = calcinfo_natom</span>
<span class="sd">      * nfr: number of fragments</span>
<span class="sd">      * &lt;varies&gt;: irregular dimension not systematically reshapable</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">schema_name</span><span class="p">:</span> <span class="n">constr</span><span class="p">(</span><span class="n">strip_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="s2">&quot;^(qcschema_molecule)$&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="n">qcschema_molecule_default</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The QCSchema specification to which this model conforms. Explicitly fixed as </span><span class="si">{</span><span class="n">qcschema_molecule_default</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">schema_version</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="mi">2</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The version number of :attr:`~qcelemental.models.Molecule.schema_name` to which this model conforms.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">validated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">False</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;A boolean indicator (for speed purposes) that the input Molecule data has been previously checked &quot;</span>
        <span class="s2">&quot;for schema (data layout and type) and physics (e.g., non-overlapping atoms, feasible &quot;</span>
        <span class="s2">&quot;multiplicity) compliance. This should be False in most cases. A ``True`` setting &quot;</span>
        <span class="s2">&quot;should only ever be set by the constructor for this class itself or other trusted sources such as &quot;</span>
        <span class="s2">&quot;a Fractal Server or previously serialized Molecules.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Required data</span>
    <span class="n">symbols</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The ordered array of atomic elemental symbols in title case. This field&#39;s index &quot;</span>
        <span class="s2">&quot;sets atomic order for all other per-atom fields like :attr:`~qcelemental.models.Molecule.real` and the first dimension of &quot;</span>
        <span class="s2">&quot;:attr:`~qcelemental.models.Molecule.geometry`. Ghost/virtual atoms must have an entry here in :attr:`~qcelemental.models.Molecule.symbols`; ghostedness is &quot;</span>
        <span class="s2">&quot;indicated through the :attr:`~qcelemental.models.Molecule.real` field.&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nat&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">geometry</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The ordered array for Cartesian XYZ atomic coordinates [a0]. &quot;</span>
        <span class="s2">&quot;Atom ordering is fixed; that is, a consumer who shuffles atoms must not reattach the input &quot;</span>
        <span class="s2">&quot;(pre-shuffling) molecule schema instance to any output (post-shuffling) per-atom results &quot;</span>
        <span class="s2">&quot;(e.g., gradient). Index of the first dimension matches the 0-indexed indices of all other &quot;</span>
        <span class="s2">&quot;per-atom settings like :attr:`~qcelemental.models.Molecule.symbols` and :attr:`~qcelemental.models.Molecule.real`.&quot;</span>
        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Serialized storage is always flat, (3*nat,), but QCSchema implementations will want to reshape it. &quot;</span>
        <span class="s2">&quot;QCElemental can also accept array-likes which can be mapped to (nat,3) such as a 1-D list of length 3*nat, &quot;</span>
        <span class="s2">&quot;or the serialized version of the array in (3*nat,) shape; all forms will be reshaped to &quot;</span>
        <span class="s2">&quot;(nat,3) for this attribute.&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nat&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
        <span class="n">units</span><span class="o">=</span><span class="s2">&quot;a0&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Molecule data</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Common or human-readable name to assign to this molecule. This field can be arbitrary; see :attr:`~qcelemental.models.Molecule.identifiers` for well-defined labels.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">identifiers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Identifiers</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;An optional dictionary of additional identifiers by which this molecule can be referenced, &quot;</span>
        <span class="s2">&quot;such as INCHI, canonical SMILES, etc. See the :class:`~qcelemental.models.results.Identifiers` model for more details.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">comment</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Additional comments for this molecule. Intended for pure human/user consumption and clarity.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">molecular_charge</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The net electrostatic charge of the molecule.&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="n">molecular_multiplicity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The total multiplicity of the molecule.&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="c1"># Atom data</span>
    <span class="n">masses_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The ordered array of atomic masses. Index order &quot;</span>
        <span class="s2">&quot;matches the 0-indexed indices of all other per-atom fields like :attr:`~qcelemental.models.Molecule.symbols` and :attr:`~qcelemental.models.Molecule.real`. If &quot;</span>
        <span class="s2">&quot;this is not provided, the mass of each atom is inferred from its most common isotope. If this &quot;</span>
        <span class="s2">&quot;is provided, it must be the same length as :attr:`~qcelemental.models.Molecule.symbols` but can accept ``None`` entries for &quot;</span>
        <span class="s2">&quot;standard masses to infer from the same index in the :attr:`~qcelemental.models.Molecule.symbols` field.&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nat&quot;</span><span class="p">],</span>
        <span class="n">units</span><span class="o">=</span><span class="s2">&quot;u&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">real_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Array</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The ordered array indicating if each atom is real (``True``) or &quot;</span>
        <span class="s2">&quot;ghost/virtual (``False``). Index &quot;</span>
        <span class="s2">&quot;matches the 0-indexed indices of all other per-atom settings like :attr:`~qcelemental.models.Molecule.symbols` and the first &quot;</span>
        <span class="s2">&quot;dimension of :attr:`~qcelemental.models.Molecule.geometry`. If this is not provided, all atoms are assumed to be real (``True``).&quot;</span>
        <span class="s2">&quot;If this is provided, the reality or ghostedness of every atom must be specified.&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nat&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">atom_labels_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Array</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Additional per-atom labels as an array of strings. Typical use is in &quot;</span>
        <span class="s2">&quot;model conversions, such as Elemental &lt;-&gt; Molpro and not typically something which should be user &quot;</span>
        <span class="s2">&quot;assigned. See the :attr:`~qcelemental.models.Molecule.comment` field for general human-consumable text to affix to the molecule.&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nat&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">atomic_numbers_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;An optional ordered 1-D array-like object of atomic numbers of shape (nat,). Index &quot;</span>
        <span class="s2">&quot;matches the 0-indexed indices of all other per-atom settings like :attr:`~qcelemental.models.Molecule.symbols` and :attr:`~qcelemental.models.Molecule.real`. &quot;</span>
        <span class="s2">&quot;Values are inferred from the :attr:`~qcelemental.models.Molecule.symbols` list if not explicitly set. &quot;</span>
        <span class="s2">&quot;Ghostedness should be indicated through :attr:`~qcelemental.models.Molecule.real` field, not zeros here.&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nat&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">mass_numbers_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;An optional ordered 1-D array-like object of atomic *mass* numbers of shape (nat). Index &quot;</span>
        <span class="s2">&quot;matches the 0-indexed indices of all other per-atom settings like :attr:`~qcelemental.models.Molecule.symbols` and :attr:`~qcelemental.models.Molecule.real`. &quot;</span>
        <span class="s2">&quot;Values are inferred from the most common isotopes of the :attr:`~qcelemental.models.Molecule.symbols` list if not explicitly set. &quot;</span>
        <span class="s2">&quot;If single isotope not (yet) known for an atom, -1 is placeholder.&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nat&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Fragment and connection data</span>
    <span class="n">connectivity_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">NonnegativeInt</span><span class="p">,</span> <span class="n">NonnegativeInt</span><span class="p">,</span> <span class="n">BondOrderFloat</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;A list of bonds within the molecule. Each entry is a tuple &quot;</span>
        <span class="s2">&quot;of ``(atom_index_A, atom_index_B, bond_order)`` where the ``atom_index`` &quot;</span>
        <span class="s2">&quot;matches the 0-indexed indices of all other per-atom settings like :attr:`~qcelemental.models.Molecule.symbols` and :attr:`~qcelemental.models.Molecule.real`. &quot;</span>
        <span class="s2">&quot;Bonds may be freely reordered and inverted.&quot;</span><span class="p">,</span>
        <span class="n">min_items</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">fragments_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;List of indices grouping atoms (0-indexed) into molecular fragments within the molecule. &quot;</span>
        <span class="s2">&quot;Each entry in the outer list is a new fragment; index matches the ordering in :attr:`~qcelemental.models.Molecule.fragment_charges` and &quot;</span>
        <span class="s2">&quot;:attr:`~qcelemental.models.Molecule.fragment_multiplicities`. Inner lists are 0-indexed atoms which compose the fragment; every atom must &quot;</span>
        <span class="s2">&quot;be in exactly one inner list. Noncontiguous fragments are allowed, though no QM program is known to support them. &quot;</span>
        <span class="s2">&quot;Fragment ordering is fixed; that is, a consumer who shuffles fragments must not reattach the input &quot;</span>
        <span class="s2">&quot;(pre-shuffling) molecule schema instance to any output (post-shuffling) per-fragment results (e.g., n-body energy arrays).&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nfr&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;varies&gt;&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">fragment_charges_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The total charge of each fragment in the :attr:`~qcelemental.models.Molecule.fragments` list. The index of this &quot;</span>
        <span class="s2">&quot;list matches the 0-index indices of :attr:`~qcelemental.models.Molecule.fragments` list. Will be filled in based on a set of rules &quot;</span>
        <span class="s2">&quot;if not provided (and :attr:`~qcelemental.models.Molecule.fragments` are specified).&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nfr&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">fragment_multiplicities_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The multiplicity of each fragment in the :attr:`~qcelemental.models.Molecule.fragments` list. The index of this &quot;</span>
        <span class="s2">&quot;list matches the 0-index indices of :attr:`~qcelemental.models.Molecule.fragments` list. Will be filled in based on a set of &quot;</span>
        <span class="s2">&quot;rules if not provided (and :attr:`~qcelemental.models.Molecule.fragments` are specified).&quot;</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;nfr&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Orientation</span>
    <span class="n">fix_com</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">False</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Whether translation of geometry is allowed (fix F) or disallowed (fix T).&quot;</span>
        <span class="s2">&quot;When False, QCElemental will pre-process the Molecule object to translate the center of mass &quot;</span>
        <span class="s2">&quot;to (0,0,0) in Euclidean coordinate space, resulting in a different :attr:`~qcelemental.models.Molecule.geometry` than the &quot;</span>
        <span class="s2">&quot;one provided. &#39;Fix&#39; is used in the sense of &#39;specify&#39;: that is, `fix_com=True` signals that &quot;</span>
        <span class="s2">&quot;the origin in `geometry` is a deliberate part of the Molecule spec, whereas `fix_com=False` &quot;</span>
        <span class="s2">&quot;(default) allows that the origin is happenstance and may be adjusted. &quot;</span>
        <span class="s2">&quot;guidance: A consumer who translates the geometry must not reattach the input (pre-translation) molecule schema instance to any output (post-translation) origin-sensitive results (e.g., an ordinary energy when EFP present).&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">fix_orientation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">False</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Whether rotation of geometry is allowed (fix F) or disallowed (fix T). &quot;</span>
        <span class="s2">&quot;When False, QCElemental will pre-process the Molecule object to orient via the intertial tensor, &quot;</span>
        <span class="s2">&quot;resulting in a different :attr:`~qcelemental.models.Molecule.geometry` than the one provided. &quot;</span>
        <span class="s2">&quot;&#39;Fix&#39; is used in the sense of &#39;specify&#39;: that is, `fix_orientation=True` signals that &quot;</span>
        <span class="s2">&quot;the frame orientation in `geometry` is a deliberate part of the Molecule spec, whereas &quot;</span>
        <span class="s2">&quot;`fix_orientation=False` (default) allows that the frame is happenstance and may be adjusted. &quot;</span>
        <span class="s2">&quot;guidance: A consumer who rotates the geometry must not reattach the input (pre-rotation) molecule schema instance to any output (post-rotation) frame-sensitive results (e.g., molecular vibrations).&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">fix_symmetry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Maximal point group symmetry which :attr:`~qcelemental.models.Molecule.geometry` should be treated. Lowercase.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Extra</span>
    <span class="n">provenance</span><span class="p">:</span> <span class="n">Provenance</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="n">default_factory</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">provenance_stamp</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">),</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;The provenance information about how this Molecule (and its attributes) were generated, &quot;</span>
        <span class="s2">&quot;provided, and manipulated.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;A unique identifier for this Molecule object. This field exists primarily for Databases &quot;</span>
        <span class="s2">&quot;(e.g. Fractal&#39;s Server) to track and lookup this specific object and should virtually &quot;</span>
        <span class="s2">&quot;never need to be manually set.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">extras</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Additional information to bundle with the molecule. Use for schema development and scratch space.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">class</span> <span class="nc">Config</span><span class="p">(</span><span class="n">ProtoModel</span><span class="o">.</span><span class="n">Config</span><span class="p">):</span>
        <span class="n">serialize_skip_defaults</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">repr_style</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;formula&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_molecular_formula</span><span class="p">()),</span>
            <span class="p">(</span><span class="s2">&quot;hash&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hash</span><span class="p">()[:</span><span class="mi">7</span><span class="p">]),</span>
        <span class="p">]</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;masses_&quot;</span><span class="p">:</span> <span class="s2">&quot;masses&quot;</span><span class="p">,</span>
            <span class="s2">&quot;real_&quot;</span><span class="p">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
            <span class="s2">&quot;atom_labels_&quot;</span><span class="p">:</span> <span class="s2">&quot;atom_labels&quot;</span><span class="p">,</span>
            <span class="s2">&quot;atomic_numbers_&quot;</span><span class="p">:</span> <span class="s2">&quot;atomic_numbers&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mass_numbers_&quot;</span><span class="p">:</span> <span class="s2">&quot;mass_numbers&quot;</span><span class="p">,</span>
            <span class="s2">&quot;connectivity_&quot;</span><span class="p">:</span> <span class="s2">&quot;connectivity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fragments_&quot;</span><span class="p">:</span> <span class="s2">&quot;fragments&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fragment_charges_&quot;</span><span class="p">:</span> <span class="s2">&quot;fragment_charges&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fragment_multiplicities_&quot;</span><span class="p">:</span> <span class="s2">&quot;fragment_multiplicities&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">def</span> <span class="nf">schema_extra</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
            <span class="c1"># below addresses the draft-04 issue until https://github.com/samuelcolvin/pydantic/issues/1478 .</span>
            <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;$schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qcschema_draft</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">validate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initializes the molecule object from dictionary-like values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orient</span>
<span class="sd">            If True, orientates the Molecule to a common reference frame.</span>
<span class="sd">        validate</span>
<span class="sd">            If ``None`` validation is always applied unless the ``validated`` flag is set. Otherwise uses the boolean to decide to validate the Molecule or not.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            The values of the Molecule object attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">validate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validate</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;validated&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">geometry_prep</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_geometry_prep&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">geometry_noise</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;geometry_noise&quot;</span><span class="p">,</span> <span class="n">GEOMETRY_NOISE</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">validate</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;schema_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;schema_name&quot;</span><span class="p">,</span> <span class="s2">&quot;qcschema_molecule&quot;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;schema_version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;schema_version&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="c1"># original_keys = set(kwargs.keys())  # revive when ready to revisit sparsity</span>

            <span class="n">nonphysical</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;nonphysical&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="n">to_schema</span><span class="p">(</span>
                <span class="n">from_schema</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">nonphysical</span><span class="o">=</span><span class="n">nonphysical</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;schema_version&quot;</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">np_out</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="n">_filter_defaults</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;validated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">schema</span><span class="p">}</span>  <span class="c1"># Allow any extra fields</span>
            <span class="n">validate</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># We are pulling out the values *explicitly* so that the pydantic skip_defaults works as expected</span>
        <span class="c1"># All attributes set below are equivalent to the default set.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

        <span class="k">if</span> <span class="n">validate</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">defchararray</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span>  <span class="c1"># Title case for consistency</span>

        <span class="k">if</span> <span class="n">orient</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">float_prep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orient_molecule_internal</span><span class="p">(),</span> <span class="n">geometry_noise</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">validate</span> <span class="ow">or</span> <span class="n">geometry_prep</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">float_prep</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span> <span class="n">geometry_noise</span><span class="p">)</span>

    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_must_be_3n</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Geometry must be castable to shape (N,3)!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;masses_&quot;</span><span class="p">,</span> <span class="s2">&quot;real_&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_must_be_n</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Masses and Real must be same number of entries as Symbols&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;real_&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_populate_real</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Can&#39;t use geometry here since its already been validated and not in values</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="nd">@validator</span><span class="p">(</span><span class="s2">&quot;fragment_charges_&quot;</span><span class="p">,</span> <span class="s2">&quot;fragment_multiplicities_&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_must_be_n_frag</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;fragments_&quot;</span> <span class="ow">in</span> <span class="n">values</span> <span class="ow">and</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;fragments_&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="s2">&quot;fragments_&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Fragment Charges and Fragment Multiplicities must be same number of entries as Fragments&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hash_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="s2">&quot;symbols&quot;</span><span class="p">,</span>
            <span class="s2">&quot;masses&quot;</span><span class="p">,</span>
            <span class="s2">&quot;molecular_charge&quot;</span><span class="p">,</span>
            <span class="s2">&quot;molecular_multiplicity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;real&quot;</span><span class="p">,</span>
            <span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fragments&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fragment_charges&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fragment_multiplicities&quot;</span><span class="p">,</span>
            <span class="s2">&quot;connectivity&quot;</span><span class="p">,</span>
        <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">masses</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;masses_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">masses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">periodictable</span><span class="o">.</span><span class="n">to_mass</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">masses</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
        <span class="n">real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;real_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">real</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">real</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atom_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">atom_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atom_labels_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atom_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atom_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">atom_labels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atomic_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">]:</span>
        <span class="n">atomic_numbers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atomic_numbers_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atomic_numbers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atomic_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">periodictable</span><span class="o">.</span><span class="n">to_Z</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">atomic_numbers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">]:</span>
        <span class="n">mass_numbers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mass_numbers_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mass_numbers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mass_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">periodictable</span><span class="o">.</span><span class="n">to_A</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">mass_numbers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;connectivity_&quot;</span><span class="p">)</span>
        <span class="c1"># default is None, not []</span>
        <span class="k">return</span> <span class="n">connectivity</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]:</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fragments_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fragments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fragments</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">fragments</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fragment_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="n">fragment_charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fragment_charges_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fragment_charges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fragment_charges</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">molecular_charge</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">fragment_charges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fragment_multiplicities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">fragment_multiplicities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fragment_multiplicities_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fragment_multiplicities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fragment_multiplicities</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">molecular_multiplicity</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">fragment_multiplicities</span>

    <span class="c1">### Non-Pydantic API functions</span>

<div class="viewcode-block" id="Molecule.show"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngl_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;nglview.NGLWidget&quot;</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a 3D representation of a molecule that can be manipulated in Jupyter Notebooks and exported as</span>
<span class="sd">        images (`.png`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ngl_kwargs</span>
<span class="sd">            Addition nglview NGLWidget kwargs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nglview.NGLWidget</span>
<span class="sd">            A nglview view of the molecule</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">which_import</span><span class="p">(</span><span class="s2">&quot;nglview&quot;</span><span class="p">,</span> <span class="n">return_bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Python module nglwview not found. Solve by installing it: `conda install -c conda-forge nglview`&quot;</span>
            <span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="kn">import</span> <span class="nn">nglview</span> <span class="k">as</span> <span class="nn">nv</span>  <span class="c1"># type: ignore</span>

        <span class="k">if</span> <span class="n">ngl_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ngl_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">structure</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">TextStructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="s2">&quot;nglview-sdf&quot;</span><span class="p">),</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;sdf&quot;</span><span class="p">)</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">NGLWidget</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="o">**</span><span class="n">ngl_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">widget</span></div>

<div class="viewcode-block" id="Molecule.measure"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.measure">[docs]</a>    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">measurements</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]],</span> <span class="o">*</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a measurement of the moleucle from the indicies provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        measurements</span>
<span class="sd">            Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if</span>
<span class="sd">            2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree.</span>
<span class="sd">        degrees</span>
<span class="sd">            Returns degrees by default, radians otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[float, List[float]]</span>
<span class="sd">            Either a value or list of the measured values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">measure_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">measurements</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.orient_molecule"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.orient_molecule">[docs]</a>    <span class="k">def</span> <span class="nf">orient_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Centers the molecule and orients via inertia tensor before returning a new Molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">())</span></div>

<div class="viewcode-block" id="Molecule.compare"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.compare">[docs]</a>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Molecule.compare is deprecated and will be removed in v0.13.0. Use == instead.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if two molecules are identical. This is a molecular identity defined</span>
<span class="sd">        by scientific terms, and not programing terms, so it&#39;s less rigorous than</span>
<span class="sd">        a programmatic equality or a memory equivalent `is`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Comparison molecule not understood of type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hash</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">get_hash</span><span class="p">()</span>

<div class="viewcode-block" id="Molecule.dict"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.dict">[docs]</a>    <span class="k">def</span> <span class="nf">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;by_alias&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;exclude_unset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.pretty_print"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.pretty_print">[docs]</a>    <span class="k">def</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.</span>
<span class="sd">        (method name in libmints is print_in_angstrom)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;    Geometry (in </span><span class="si">{0:s}</span><span class="s2">), charge = </span><span class="si">{1:.1f}</span><span class="s2">, multiplicity = </span><span class="si">{2:d}</span><span class="s2">:</span><span class="se">\n\n</span><span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s2">&quot;Angstrom&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecular_charge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecular_multiplicity</span>
        <span class="p">)</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;       Center              X                  Y                   Z       </span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;    ------------   -----------------  -----------------  -----------------</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)):</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;    </span><span class="si">{0:8s}{1:4s}</span><span class="s2"> &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;(Gh)&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;  </span><span class="si">{0:17.12f}</span><span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">conversion_factor</span><span class="p">(</span><span class="s2">&quot;bohr&quot;</span><span class="p">,</span> <span class="s2">&quot;angstroms&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="c1"># text += &quot;\n&quot;</span>

        <span class="k">return</span> <span class="n">text</span></div>

<div class="viewcode-block" id="Molecule.get_fragment"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.get_fragment">[docs]</a>    <span class="k">def</span> <span class="nf">get_fragment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">real</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">],</span>
        <span class="n">ghost</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">orient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">group_fragments</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get new Molecule with fragments preserved, dropped, or ghosted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        real</span>
<span class="sd">            Fragment index or list of indices (0-indexed) to be real atoms in new Molecule.</span>
<span class="sd">        ghost</span>
<span class="sd">            Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule.</span>
<span class="sd">        orient</span>
<span class="sd">            Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation</span>
<span class="sd">            (according to _orient_molecule_internal)?</span>
<span class="sd">        group_fragments</span>
<span class="sd">            Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back.</span>
<span class="sd">            Previous to ``v0.5``, this was always effectively True. True is handy for finding duplicate</span>
<span class="sd">            (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for</span>
<span class="sd">            absent fragments) like Psi4&#39;s ``extract_subsets``. False is handy for gradients where atom order of</span>
<span class="sd">            returned values matters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Molecule</span>
<span class="sd">            New qcelemental.models.Molecule with ``self``\&#39;s fragments present, ghosted, or absent.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">real</span> <span class="o">=</span> <span class="p">[</span><span class="n">real</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ghost</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ghost</span> <span class="o">=</span> <span class="p">[</span><span class="n">ghost</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ghost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ghost</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">constructor_dict</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">ret_name</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ghost</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_name</span>
        <span class="c1"># ret = Molecule(None, name=ret_name)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">real</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">ghost</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Molecule:get_fragment: real and ghost sets are overlapping! (</span><span class="si">{0}</span><span class="s2">, </span><span class="si">{1}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">real</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">ghost</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">geom_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">real_atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fragment_charges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fragment_multiplicities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">atom_size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">group_fragments</span><span class="p">:</span>

            <span class="c1"># Loop through the real blocks</span>
            <span class="n">frag_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">real</span><span class="p">:</span>
                <span class="n">frag_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">frag</span><span class="p">])</span>
                <span class="n">geom_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">frag</span><span class="p">]])</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">frag</span><span class="p">]:</span>
                    <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="n">real_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">masses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

                <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">frag_start</span><span class="p">,</span> <span class="n">frag_start</span> <span class="o">+</span> <span class="n">frag_size</span><span class="p">)))</span>
                <span class="n">frag_start</span> <span class="o">+=</span> <span class="n">frag_size</span>

                <span class="n">fragment_charges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragment_charges</span><span class="p">[</span><span class="n">frag</span><span class="p">]))</span>
                <span class="n">fragment_multiplicities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragment_multiplicities</span><span class="p">[</span><span class="n">frag</span><span class="p">])</span>

            <span class="c1"># Set charge and multiplicity</span>
            <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;molecular_charge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fragment_charges</span><span class="p">)</span>
            <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;molecular_multiplicity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fragment_multiplicities</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Loop through the ghost blocks</span>
            <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">ghost</span><span class="p">:</span>
                <span class="n">frag_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">frag</span><span class="p">])</span>
                <span class="n">geom_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">frag</span><span class="p">]])</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">frag</span><span class="p">]:</span>
                    <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="n">real_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">masses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

                <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">frag_start</span><span class="p">,</span> <span class="n">frag_start</span> <span class="o">+</span> <span class="n">frag_size</span><span class="p">)))</span>
                <span class="n">frag_start</span> <span class="o">+=</span> <span class="n">frag_size</span>

                <span class="n">fragment_charges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">fragment_multiplicities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># List[Array[np.int32]]</span>
            <span class="n">at2fr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">fr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">iat</span> <span class="ow">in</span> <span class="n">fr</span><span class="p">:</span>
                    <span class="n">at2fr</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifr</span>

            <span class="n">at2at</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)):</span>
                <span class="n">ifr</span> <span class="o">=</span> <span class="n">at2fr</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">ifr</span> <span class="ow">in</span> <span class="n">real</span> <span class="ow">or</span> <span class="n">ifr</span> <span class="ow">in</span> <span class="n">ghost</span><span class="p">:</span>
                    <span class="n">geom_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="n">iat</span><span class="p">])</span>
                    <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">iat</span><span class="p">])</span>
                    <span class="n">real_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ifr</span> <span class="ow">in</span> <span class="n">real</span><span class="p">)</span>
                    <span class="n">masses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">iat</span><span class="p">])</span>

                    <span class="n">at2at</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_size</span>
                    <span class="n">atom_size</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">at2at</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">fr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ifr</span> <span class="ow">in</span> <span class="n">real</span> <span class="ow">or</span> <span class="n">ifr</span> <span class="ow">in</span> <span class="n">ghost</span><span class="p">:</span>
                    <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">at2at</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span> <span class="k">for</span> <span class="n">iat</span> <span class="ow">in</span> <span class="n">fr</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">ifr</span> <span class="ow">in</span> <span class="n">real</span><span class="p">:</span>
                    <span class="n">fragment_charges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragment_charges</span><span class="p">[</span><span class="n">ifr</span><span class="p">])</span>
                    <span class="n">fragment_multiplicities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragment_multiplicities</span><span class="p">[</span><span class="n">ifr</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">ifr</span> <span class="ow">in</span> <span class="n">ghost</span><span class="p">:</span>
                    <span class="n">fragment_charges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">fragment_multiplicities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">assert</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fragments</span>

        <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;fragments&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fragments</span>
        <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;fragment_charges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fragment_charges</span>
        <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;fragment_multiplicities&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fragment_multiplicities</span>
        <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbols</span>
        <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">geom_blocks</span><span class="p">)</span>
        <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;real&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">real_atoms</span>
        <span class="n">constructor_dict</span><span class="p">[</span><span class="s2">&quot;masses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">masses</span>

        <span class="k">return</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="n">orient</span><span class="p">,</span> <span class="o">**</span><span class="n">constructor_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.to_string"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">units</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">atom_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ghost_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
        <span class="n">prec</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
        <span class="n">return_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns a string that can be used by a variety of programs.</span>

<span class="sd">        Unclear if this will be removed or renamed to &quot;to_psi4_string&quot; in the future</span>

<span class="sd">        Suggest psi4 --&gt; psi4frag and psi4 route to to_string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">molrec</span> <span class="o">=</span> <span class="n">from_schema</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">(),</span> <span class="n">nonphysical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_string</span><span class="p">(</span>
            <span class="n">molrec</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span>
            <span class="n">atom_format</span><span class="o">=</span><span class="n">atom_format</span><span class="p">,</span>
            <span class="n">ghost_format</span><span class="o">=</span><span class="n">ghost_format</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">prec</span><span class="o">=</span><span class="n">prec</span><span class="p">,</span>
            <span class="n">return_data</span><span class="o">=</span><span class="n">return_data</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.get_hash"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.get_hash">[docs]</a>    <span class="k">def</span> <span class="nf">get_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the hash of the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">()</span>
        <span class="n">concat</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_fields</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">float_prep</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">GEOMETRY_NOISE</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s2">&quot;fragment_charges&quot;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">float_prep</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">CHARGE_NOISE</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s2">&quot;molecular_charge&quot;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">float_prep</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">CHARGE_NOISE</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s2">&quot;masses&quot;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">float_prep</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">MASS_NOISE</span><span class="p">)</span>

            <span class="n">concat</span> <span class="o">+=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">concat</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>

<div class="viewcode-block" id="Molecule.get_molecular_formula"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.get_molecular_formula">[docs]</a>    <span class="k">def</span> <span class="nf">get_molecular_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;alphabetical&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the molecular formula for a molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order: str, optional</span>
<span class="sd">            Sorting order of the formula. Valid choices are &quot;alphabetical&quot; and &quot;hill&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The molecular formula.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; methane = qcelemental.models.Molecule(&#39;&#39;&#39;</span>
<span class="sd">        ... H      0.5288      0.1610      0.9359</span>
<span class="sd">        ... C      0.0000      0.0000      0.0000</span>
<span class="sd">        ... H      0.2051      0.8240     -0.6786</span>
<span class="sd">        ... H      0.3345     -0.9314     -0.4496</span>
<span class="sd">        ... H     -1.0685     -0.0537      0.1921</span>
<span class="sd">        ... &#39;&#39;&#39;)</span>
<span class="sd">        &gt;&gt;&gt; methane.get_molecular_formula()</span>
<span class="sd">        CH4</span>

<span class="sd">        &gt;&gt;&gt; hcl = qcelemental.models.Molecule(&#39;&#39;&#39;</span>
<span class="sd">        ... H      0.0000      0.0000      0.0000</span>
<span class="sd">        ... Cl     0.0000      0.0000      1.2000</span>
<span class="sd">        ... &#39;&#39;&#39;)</span>
<span class="sd">        &gt;&gt;&gt; hcl.get_molecular_formula()</span>
<span class="sd">        ClH</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">..molutil</span> <span class="kn">import</span> <span class="n">molecular_formula_from_symbols</span>

        <span class="k">return</span> <span class="n">molecular_formula_from_symbols</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>

    <span class="c1">### Constructors</span>

<div class="viewcode-block" id="Molecule.from_data"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.from_data">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_data</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">],</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">orient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">validate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a molecule object from a data structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            Data to construct Molecule from</span>
<span class="sd">        dtype</span>
<span class="sd">            How to interpret the data, if not passed attempts to discover this based on input type.</span>
<span class="sd">        orient</span>
<span class="sd">            Orientates the molecule to a standard frame or not.</span>
<span class="sd">        validate</span>
<span class="sd">            Validates the molecule or not.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional kwargs to pass to the constructors. kwargs take precedence over data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Molecule</span>
<span class="sd">            A constructed molecule class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;numpy&quot;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;dict&quot;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;msgpack&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input type not understood, please supply the &#39;dtype&#39; kwarg.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;psi4&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz+&quot;</span><span class="p">]:</span>
            <span class="n">mol_dict</span> <span class="o">=</span> <span class="n">from_string</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mol_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
            <span class="n">input_dict</span> <span class="o">=</span> <span class="n">to_schema</span><span class="p">(</span><span class="n">mol_dict</span><span class="p">[</span><span class="s2">&quot;qm&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">np_out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">input_dict</span> <span class="o">=</span> <span class="n">_filter_defaults</span><span class="p">(</span><span class="n">input_dict</span><span class="p">)</span>
            <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;validated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;_geometry_prep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;numpy&quot;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;geom&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span>
                <span class="s2">&quot;elez&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;units&quot;</span><span class="p">,</span> <span class="s2">&quot;Angstrom&quot;</span><span class="p">),</span>
                <span class="s2">&quot;fragment_separators&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;frags&quot;</span><span class="p">,</span> <span class="p">[]),</span>
            <span class="p">}</span>
            <span class="n">input_dict</span> <span class="o">=</span> <span class="n">to_schema</span><span class="p">(</span><span class="n">from_arrays</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">np_out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">input_dict</span> <span class="o">=</span> <span class="n">_filter_defaults</span><span class="p">(</span><span class="n">input_dict</span><span class="p">)</span>
            <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;validated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;_geometry_prep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;msgpack&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
            <span class="n">input_dict</span> <span class="o">=</span> <span class="n">msgpackext_loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;json&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="n">input_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;dict&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
            <span class="n">input_dict</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Dtype not understood &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>

        <span class="n">input_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># if charge/spin options are given, invalidate charge and spin options that are missing</span>
        <span class="n">charge_spin_opts</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;molecular_charge&quot;</span><span class="p">,</span> <span class="s2">&quot;fragment_charges&quot;</span><span class="p">,</span> <span class="s2">&quot;molecular_multiplicity&quot;</span><span class="p">,</span> <span class="s2">&quot;fragment_multiplicities&quot;</span><span class="p">}</span>
        <span class="n">kwarg_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">charge_spin_opts</span> <span class="o">&amp;</span> <span class="n">kwarg_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">charge_spin_opts</span> <span class="o">-</span> <span class="n">kwarg_keys</span><span class="p">:</span>
                <span class="n">input_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">input_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;validated&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="n">orient</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span> <span class="o">**</span><span class="n">input_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.from_file"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">orient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a molecule object from a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename</span>
<span class="sd">            The filename to build</span>
<span class="sd">        dtype</span>
<span class="sd">            The type of file to interpret.</span>
<span class="sd">        orient</span>
<span class="sd">            Orientates the molecule to a standard frame or not.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Any additional keywords to pass to the constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Molecule</span>
<span class="sd">            A constructed molecule class.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ext</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">_extension_map</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">_extension_map</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Let `from_string` try to sort it</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;string&quot;</span>

        <span class="c1"># Raw string type, read and pass through</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz+&quot;</span><span class="p">,</span> <span class="s2">&quot;psi4&quot;</span><span class="p">]:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;numpy&quot;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;json&quot;</span><span class="p">,</span> <span class="s2">&quot;json-ext&quot;</span><span class="p">]:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;json-ext&quot;</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;dict&quot;</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;msgpack&quot;</span><span class="p">,</span> <span class="s2">&quot;msgpack-ext&quot;</span><span class="p">]:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile_bytes</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">deserialize</span><span class="p">(</span><span class="n">infile_bytes</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;msgpack-ext&quot;</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;dict&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Dtype not understood &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="n">orient</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.to_file"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.to_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Writes the Molecule to a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename</span>
<span class="sd">            The filename to write to</span>
<span class="sd">        dtype</span>
<span class="sd">            The type of file to write, attempts to infer dtype from the filename if not provided.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">_extension_map</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">_extension_map</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not infer dtype from filename: `</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz+&quot;</span><span class="p">,</span> <span class="s2">&quot;psi4&quot;</span><span class="p">]:</span>
            <span class="n">stringified</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;json&quot;</span><span class="p">,</span> <span class="s2">&quot;json-ext&quot;</span><span class="p">,</span> <span class="s2">&quot;msgpack&quot;</span><span class="p">,</span> <span class="s2">&quot;msgpack-ext&quot;</span><span class="p">]:</span>
            <span class="n">stringified</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;numpy&quot;</span><span class="p">]:</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">npmol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">conversion_factor</span><span class="p">(</span><span class="s2">&quot;bohr&quot;</span><span class="p">,</span> <span class="s2">&quot;angstroms&quot;</span><span class="p">)))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">npmol</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dtype `</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` is not valid&quot;</span><span class="p">)</span>

        <span class="n">flags</span> <span class="o">=</span> <span class="s2">&quot;wb&quot;</span> <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;msgpack&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;w&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
            <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">stringified</span><span class="p">)</span></div>

    <span class="c1">### Non-Pydantic internal functions</span>

    <span class="k">def</span> <span class="nf">_orient_molecule_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Centers the molecule and orients via inertia tensor before returning a new set of the</span>
<span class="sd">        molecule geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Ensure we get a copy</span>
        <span class="c1"># Get the mass as an array</span>
        <span class="c1"># Masses are needed for orientation</span>
        <span class="n">np_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span>

        <span class="c1"># Center on Mass</span>
        <span class="n">new_geometry</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">new_geometry</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">np_mass</span><span class="p">)</span>

        <span class="c1"># Rotate into inertial frame</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inertial_tensor</span><span class="p">(</span><span class="n">new_geometry</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">np_mass</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>

        <span class="n">new_geometry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">new_geometry</span><span class="p">,</span> <span class="n">evecs</span><span class="p">)</span>

        <span class="c1"># Phases? Lets do the simplest thing and ensure the first atom in each column</span>
        <span class="c1"># that is not on a plane is positve</span>

        <span class="n">phase_check</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

        <span class="n">geom_noise</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">GEOMETRY_NOISE</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_geometry</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">phase_check</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="n">val</span> <span class="o">=</span> <span class="n">new_geometry</span><span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">geom_noise</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">phase_check</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_geometry</span><span class="p">[:,</span> <span class="n">x</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">phase_check</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">new_geometry</span>

    <span class="k">def</span> <span class="nf">__repr_args__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ReprArgs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;formula&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_molecular_formula</span><span class="p">()),</span> <span class="p">(</span><span class="s2">&quot;hash&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hash</span><span class="p">()[:</span><span class="mi">7</span><span class="p">])]</span>

    <span class="k">def</span> <span class="nf">_ipython_display_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">()</span><span class="o">.</span><span class="n">_ipython_display_</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>

            <span class="n">display</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Install nglview for interactive visualization.&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_inertial_tensor</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the moment inertia tensor for a given geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build inertia tensor</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Diagonal</span>
        <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="p">(</span><span class="n">geom</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">geom</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">))</span>
        <span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="p">(</span><span class="n">geom</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">geom</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">))</span>
        <span class="n">tensor</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="p">(</span><span class="n">geom</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">geom</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">))</span>

        <span class="c1"># I(alpha, beta)</span>
        <span class="c1"># Off diagonal</span>
        <span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">geom</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">geom</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">tensor</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">geom</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">geom</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">tensor</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">geom</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">geom</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">tensor</span>

<div class="viewcode-block" id="Molecule.nuclear_repulsion_energy"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.nuclear_repulsion_energy">[docs]</a>    <span class="k">def</span> <span class="nf">nuclear_repulsion_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ifr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Nuclear repulsion energy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ifr</span>
<span class="sd">            If not `None`, only compute for the `ifr`-th (0-indexed) fragment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nre : float</span>
<span class="sd">            Nuclear repulsion energy in entire molecule or in fragment.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Zeff</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">real</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">real</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">)]</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">ifr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">ifr</span><span class="p">]</span>

        <span class="n">nre</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">iat1</span><span class="p">,</span> <span class="n">at1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">at2</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">[:</span><span class="n">iat1</span><span class="p">]:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="n">at1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="n">at2</span><span class="p">])</span>
                <span class="n">nre</span> <span class="o">+=</span> <span class="n">Zeff</span><span class="p">[</span><span class="n">at1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Zeff</span><span class="p">[</span><span class="n">at2</span><span class="p">]</span> <span class="o">/</span> <span class="n">dist</span>
        <span class="k">return</span> <span class="n">nre</span></div>

<div class="viewcode-block" id="Molecule.nelectrons"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.nelectrons">[docs]</a>    <span class="k">def</span> <span class="nf">nelectrons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ifr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Number of electrons.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ifr</span>
<span class="sd">            If not `None`, only compute for the `ifr`-th (0-indexed) fragment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nelec : int</span>
<span class="sd">            Number of electrons in entire molecule or in fragment.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Zeff</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">real</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">real</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">ifr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nel</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Zeff</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecular_charge</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">nel</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">zf</span> <span class="k">for</span> <span class="n">iat</span><span class="p">,</span> <span class="n">zf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Zeff</span><span class="p">)</span> <span class="k">if</span> <span class="n">iat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">ifr</span><span class="p">]])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_charges</span><span class="p">[</span><span class="n">ifr</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">nel</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.align"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.align">[docs]</a>    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ref_mol</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">do_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">atoms_map</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">run_resorting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mols_align</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">run_to_completion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">uno_cutoff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0e-3</span><span class="p">,</span>
        <span class="n">run_mirror</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">generic_ghosts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Finds shift, rotation, and atom reordering of `concern_mol` (self)</span>
<span class="sd">        that best aligns with `ref_mol`.</span>

<span class="sd">        Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`qcelemental.models.Molecule`.</span>
<span class="sd">        Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate</span>
<span class="sd">        the best alignment for non-oriented, non-ordered structures.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref_mol : qcelemental.models.Molecule</span>
<span class="sd">            Molecule to match.</span>
<span class="sd">        atoms_map</span>
<span class="sd">            Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc.</span>
<span class="sd">            If true, specifying `True` can save much time.</span>
<span class="sd">        mols_align</span>
<span class="sd">            Whether ref_mol and concern_mol have identical geometries</span>
<span class="sd">            (barring orientation or atom mapping) and expected final RMSD = 0.</span>
<span class="sd">            If `True`, procedure is truncated when RMSD condition met, saving time.</span>
<span class="sd">            If float, RMSD tolerance at which search for alignment stops. If provided,</span>
<span class="sd">            the alignment routine will throw an error if it fails to align</span>
<span class="sd">            the molecule within the specified RMSD tolerance.</span>
<span class="sd">        do_plot</span>
<span class="sd">            Pops up a mpl plot showing before, after, and ref geometries.</span>
<span class="sd">        run_to_completion</span>
<span class="sd">            Run reorderings to completion (past RMSD = 0) even if unnecessary because</span>
<span class="sd">            `mols_align=True`. Used to test worst-case timings.</span>
<span class="sd">        run_resorting</span>
<span class="sd">            Run the resorting machinery even if unnecessary because `atoms_map=True`.</span>
<span class="sd">        uno_cutoff</span>
<span class="sd">            TODO</span>
<span class="sd">        run_mirror</span>
<span class="sd">            Run alternate geometries potentially allowing best match to `ref_mol`</span>
<span class="sd">            from mirror image of `concern_mol`. Only run if system confirmed to</span>
<span class="sd">            be nonsuperimposable upon mirror reflection.</span>
<span class="sd">        generic_ghosts</span>
<span class="sd">            When one or both molecules doesn&#39;t have meaningful element info for ghosts (can happen</span>
<span class="sd">            when harvesting from a printout with a generic ghost symbol), set this to True to</span>
<span class="sd">            place all real=False atoms into the same space for alignment. Only allowed when</span>
<span class="sd">            ``atoms_map=True``.</span>
<span class="sd">        verbose</span>
<span class="sd">            Print level.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mol : Molecule</span>
<span class="sd">        data : Dict[key, Any]</span>
<span class="sd">            Molecule is internal geometry of `self` optimally aligned and atom-ordered</span>
<span class="sd">            to `ref_mol`. Presently all fragment information is discarded.</span>
<span class="sd">            `data[&#39;rmsd&#39;]` is RMSD [A] between `ref_mol` and the optimally aligned</span>
<span class="sd">            geometry computed.</span>
<span class="sd">            `data[&#39;mill&#39;]` is a AlignmentMill with fields</span>
<span class="sd">            (shift, rotation, atommap, mirror) that prescribe the transformation</span>
<span class="sd">            from `concern_mol` and the optimally aligned geometry.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..molutil.align</span> <span class="kn">import</span> <span class="n">B787</span>

        <span class="n">rgeom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
        <span class="n">runiq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">((</span><span class="n">sym</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mas</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">sym</span><span class="p">,</span> <span class="n">mas</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">ref_mol</span><span class="o">.</span><span class="n">symbols</span><span class="p">),</span> <span class="n">ref_mol</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">concern_mol</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">cgeom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
        <span class="n">cuniq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">((</span><span class="n">sym</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mas</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">sym</span><span class="p">,</span> <span class="n">mas</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">concern_mol</span><span class="o">.</span><span class="n">symbols</span><span class="p">),</span> <span class="n">concern_mol</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">generic_ghosts</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mols_align</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too risky to lump ghosts together when mols not superimposable.&quot;</span><span class="p">)</span>

            <span class="n">bq_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">((</span><span class="s2">&quot;bq&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
            <span class="n">runiq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([(</span><span class="n">rl_hash</span> <span class="k">if</span> <span class="n">rl</span> <span class="k">else</span> <span class="n">bq_hash</span><span class="p">)</span> <span class="k">for</span> <span class="n">rl</span><span class="p">,</span> <span class="n">rl_hash</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">runiq</span><span class="p">)])</span>
            <span class="n">cuniq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([(</span><span class="n">rl_hash</span> <span class="k">if</span> <span class="n">rl</span> <span class="k">else</span> <span class="n">bq_hash</span><span class="p">)</span> <span class="k">for</span> <span class="n">rl</span><span class="p">,</span> <span class="n">rl_hash</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cuniq</span><span class="p">)])</span>

        <span class="n">rmsd</span><span class="p">,</span> <span class="n">solution</span> <span class="o">=</span> <span class="n">B787</span><span class="p">(</span>
            <span class="n">cgeom</span><span class="o">=</span><span class="n">cgeom</span><span class="p">,</span>
            <span class="n">rgeom</span><span class="o">=</span><span class="n">rgeom</span><span class="p">,</span>
            <span class="n">cuniq</span><span class="o">=</span><span class="n">cuniq</span><span class="p">,</span>
            <span class="n">runiq</span><span class="o">=</span><span class="n">runiq</span><span class="p">,</span>
            <span class="n">do_plot</span><span class="o">=</span><span class="n">do_plot</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">atoms_map</span><span class="o">=</span><span class="n">atoms_map</span><span class="p">,</span>
            <span class="n">run_resorting</span><span class="o">=</span><span class="n">run_resorting</span><span class="p">,</span>
            <span class="n">mols_align</span><span class="o">=</span><span class="n">mols_align</span><span class="p">,</span>
            <span class="n">run_to_completion</span><span class="o">=</span><span class="n">run_to_completion</span><span class="p">,</span>
            <span class="n">run_mirror</span><span class="o">=</span><span class="n">run_mirror</span><span class="p">,</span>
            <span class="n">uno_cutoff</span><span class="o">=</span><span class="n">uno_cutoff</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">aupdate</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;symbols&quot;</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">symbols</span><span class="p">),</span>
            <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">align_coordinates</span><span class="p">(</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">&quot;masses&quot;</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">masses</span><span class="p">),</span>
            <span class="s2">&quot;real&quot;</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">real</span><span class="p">),</span>
            <span class="s2">&quot;atom_labels&quot;</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">atom_labels</span><span class="p">),</span>
            <span class="s2">&quot;atomic_numbers&quot;</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">),</span>
            <span class="s2">&quot;mass_numbers&quot;</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">mass_numbers</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">adict</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">concern_mol</span><span class="o">.</span><span class="n">dict</span><span class="p">(),</span> <span class="o">**</span><span class="n">aupdate</span><span class="p">}</span>

        <span class="c1"># preserve intrinsic symmetry with lighter truncation</span>
        <span class="n">amol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">adict</span><span class="p">,</span> <span class="n">geometry_noise</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>

        <span class="c1"># TODO -- can probably do more with fragments in amol now that</span>
        <span class="c1">#         Mol is something with non-contig frags. frags now discarded.</span>

        <span class="k">assert</span> <span class="n">compare_values</span><span class="p">(</span>
            <span class="n">concern_mol</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">(),</span>
            <span class="n">amol</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">(),</span>
            <span class="s2">&quot;Q: concern_mol--&gt;returned_mol NRE uncorrupted&quot;</span><span class="p">,</span>
            <span class="n">atol</span><span class="o">=</span><span class="mf">1.0e-4</span><span class="p">,</span>
            <span class="n">quiet</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">mols_align</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">compare_values</span><span class="p">(</span>
                <span class="n">ref_mol</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">(),</span>
                <span class="n">amol</span><span class="o">.</span><span class="n">nuclear_repulsion_energy</span><span class="p">(),</span>
                <span class="s2">&quot;Q: concern_mol--&gt;returned_mol NRE matches ref_mol&quot;</span><span class="p">,</span>
                <span class="n">atol</span><span class="o">=</span><span class="mf">1.0e-4</span><span class="p">,</span>
                <span class="n">quiet</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">compare</span><span class="p">(</span>
                <span class="kc">True</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">amol</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span>
                <span class="s2">&quot;Q: concern_mol--&gt;returned_mol geometry matches ref_mol&quot;</span><span class="p">,</span>
                <span class="n">quiet</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">amol</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;rmsd&quot;</span><span class="p">:</span> <span class="n">rmsd</span><span class="p">,</span> <span class="s2">&quot;mill&quot;</span><span class="p">:</span> <span class="n">solution</span><span class="p">}</span></div>

<div class="viewcode-block" id="Molecule.scramble"><a class="viewcode-back" href="../../../model_molecule.html#qcelemental.models.Molecule.scramble">[docs]</a>    <span class="k">def</span> <span class="nf">scramble</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">do_shift</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">do_rotate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">do_resort</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">deflection</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">do_mirror</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">do_plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">do_test</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">run_to_completion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">run_resorting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate a Molecule with random or directed translation, rotation, and atom shuffling.</span>
<span class="sd">        Optionally, check that the aligner returns the opposite transformation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref_mol : qcelemental.models.Molecule</span>
<span class="sd">            Molecule to perturb.</span>
<span class="sd">        do_shift</span>
<span class="sd">            Whether to generate a random atom shift on interval [-3, 3) in each</span>
<span class="sd">            dimension (`True`) or leave at current origin. To shift by a specified</span>
<span class="sd">            vector, supply a 3-element list.</span>
<span class="sd">        do_rotate</span>
<span class="sd">            Whether to generate a random 3D rotation according to algorithm of Arvo.</span>
<span class="sd">            To rotate by a specified matrix, supply a 9-element list of lists.</span>
<span class="sd">        do_resort</span>
<span class="sd">            Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`).</span>
<span class="sd">            To specify shuffle, supply a nat-element list of indices.</span>
<span class="sd">        deflection</span>
<span class="sd">            If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small</span>
<span class="sd">            perturbation, 1.0 is completely random.</span>
<span class="sd">        do_mirror</span>
<span class="sd">            Whether to construct the mirror image structure by inverting y-axis.</span>
<span class="sd">        do_plot</span>
<span class="sd">            Pops up a mpl plot showing before, after, and ref geometries.</span>
<span class="sd">        do_test</span>
<span class="sd">            Additionally, run the aligner on the returned Molecule and check that</span>
<span class="sd">            opposite transformations obtained.</span>
<span class="sd">        run_to_completion</span>
<span class="sd">            By construction, scrambled systems are fully alignable (final RMSD=0).</span>
<span class="sd">            Even so, `True` turns off the mechanism to stop when RMSD reaches zero</span>
<span class="sd">            and instead proceed to worst possible time.</span>
<span class="sd">        run_resorting</span>
<span class="sd">            Even if atoms not shuffled, test the resorting machinery.</span>
<span class="sd">        verbose</span>
<span class="sd">            Print level.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mol : Molecule</span>
<span class="sd">        data : Dict[key, Any]</span>
<span class="sd">            Molecule is scrambled copy of `ref_mol` (self).</span>
<span class="sd">            `data[&#39;rmsd&#39;]` is RMSD [A] between `ref_mol` and the scrambled geometry.</span>
<span class="sd">            `data[&#39;mill&#39;]` is a AlignmentMill with fields</span>
<span class="sd">            (shift, rotation, atommap, mirror) that prescribe the transformation</span>
<span class="sd">            from `ref_mol` to the returned geometry.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            If `do_test=True` and aligner sanity check fails for any of the reverse</span>
<span class="sd">            transformations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..molutil.align</span> <span class="kn">import</span> <span class="n">compute_scramble</span>

        <span class="n">ref_mol</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">rgeom</span> <span class="o">=</span> <span class="n">ref_mol</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="n">rgeom</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">perturbation</span> <span class="o">=</span> <span class="n">compute_scramble</span><span class="p">(</span>
            <span class="n">nat</span><span class="p">,</span>
            <span class="n">do_shift</span><span class="o">=</span><span class="n">do_shift</span><span class="p">,</span>
            <span class="n">do_rotate</span><span class="o">=</span><span class="n">do_rotate</span><span class="p">,</span>
            <span class="n">deflection</span><span class="o">=</span><span class="n">deflection</span><span class="p">,</span>
            <span class="n">do_resort</span><span class="o">=</span><span class="n">do_resort</span><span class="p">,</span>
            <span class="n">do_mirror</span><span class="o">=</span><span class="n">do_mirror</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">cgeom</span> <span class="o">=</span> <span class="n">perturbation</span><span class="o">.</span><span class="n">align_coordinates</span><span class="p">(</span><span class="n">rgeom</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cupdate</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;symbols&quot;</span><span class="p">:</span> <span class="n">perturbation</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">symbols</span><span class="p">),</span>
            <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">cgeom</span><span class="p">,</span>
            <span class="s2">&quot;masses&quot;</span><span class="p">:</span> <span class="n">perturbation</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">masses</span><span class="p">),</span>
            <span class="s2">&quot;real&quot;</span><span class="p">:</span> <span class="n">perturbation</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">real</span><span class="p">),</span>
            <span class="s2">&quot;atom_labels&quot;</span><span class="p">:</span> <span class="n">perturbation</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">atom_labels</span><span class="p">),</span>
            <span class="s2">&quot;atomic_numbers&quot;</span><span class="p">:</span> <span class="n">perturbation</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">),</span>
            <span class="s2">&quot;mass_numbers&quot;</span><span class="p">:</span> <span class="n">perturbation</span><span class="o">.</span><span class="n">align_atoms</span><span class="p">(</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">mass_numbers</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">cdict</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">ref_mol</span><span class="o">.</span><span class="n">dict</span><span class="p">(),</span> <span class="o">**</span><span class="n">cupdate</span><span class="p">}</span>

        <span class="c1"># preserve intrinsic symmetry with lighter truncation</span>
        <span class="n">cmol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">cdict</span><span class="p">,</span> <span class="n">geometry_noise</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>

        <span class="n">rmsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cgeom</span> <span class="o">-</span> <span class="n">rgeom</span><span class="p">)</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">bohr2angstroms</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start RMSD = </span><span class="si">{:8.4f}</span><span class="s2"> [A]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rmsd</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">do_test</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">cmol</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
                <span class="n">ref_mol</span><span class="p">,</span>
                <span class="n">do_plot</span><span class="o">=</span><span class="n">do_plot</span><span class="p">,</span>
                <span class="n">atoms_map</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">do_resort</span><span class="p">),</span>
                <span class="n">run_resorting</span><span class="o">=</span><span class="n">run_resorting</span><span class="p">,</span>
                <span class="n">mols_align</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">run_to_completion</span><span class="o">=</span><span class="n">run_to_completion</span><span class="p">,</span>
                <span class="n">run_mirror</span><span class="o">=</span><span class="n">do_mirror</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;mill&quot;</span><span class="p">]</span>

            <span class="k">assert</span> <span class="n">compare</span><span class="p">(</span>
                <span class="kc">True</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="n">perturbation</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1.0e-6</span><span class="p">),</span> <span class="s2">&quot;shifts equiv&quot;</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">do_resort</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">compare</span><span class="p">(</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">solution</span><span class="o">.</span><span class="n">rotation</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">perturbation</span><span class="o">.</span><span class="n">rotation</span><span class="p">),</span>
                    <span class="s2">&quot;rotations transpose&quot;</span><span class="p">,</span>
                    <span class="n">quiet</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">solution</span><span class="o">.</span><span class="n">mirror</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">compare</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_mirror</span><span class="p">,</span> <span class="s2">&quot;mirror allowed&quot;</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cmol</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;rmsd&quot;</span><span class="p">:</span> <span class="n">rmsd</span><span class="p">,</span> <span class="s2">&quot;mill&quot;</span><span class="p">:</span> <span class="n">perturbation</span><span class="p">}</span></div></div>


<span class="k">def</span> <span class="nf">_filter_defaults</span><span class="p">(</span><span class="n">dicary</span><span class="p">):</span>
    <span class="n">nat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dicary</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span>
    <span class="n">default_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">periodictable</span><span class="o">.</span><span class="n">to_mass</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">dicary</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">]])</span>

    <span class="n">dicary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;atomic_numbers&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">default_mass</span><span class="p">,</span> <span class="n">dicary</span><span class="p">[</span><span class="s2">&quot;masses&quot;</span><span class="p">]):</span>
        <span class="n">dicary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;mass_numbers&quot;</span><span class="p">)</span>
        <span class="n">dicary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;masses&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">dicary</span><span class="p">[</span><span class="s2">&quot;real&quot;</span><span class="p">]):</span>
        <span class="n">dicary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;real&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dicary</span><span class="p">[</span><span class="s2">&quot;atom_labels&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">nat</span> <span class="o">*</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]:</span>
        <span class="n">dicary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;atom_labels&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dicary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;connectivity&quot;</span><span class="p">,</span> <span class="s2">&quot;N/A&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dicary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;connectivity&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dicary</span><span class="p">[</span><span class="s2">&quot;fragments&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nat</span><span class="p">))]:</span>
        <span class="n">dicary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fragments&quot;</span><span class="p">)</span>
        <span class="n">dicary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fragment_charges&quot;</span><span class="p">)</span>
        <span class="n">dicary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fragment_multiplicities&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dicary</span>


<span class="c1"># auto_gen_docs_on_demand(Molecule)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-2022, The Molecular Sciences Software Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>